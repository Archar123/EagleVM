#include "eaglevm-core/virtual_machine/ir/x86/handlers/jcc.h"

#include "eaglevm-core/virtual_machine/ir/commands/cmd_rflags_load.h"
#include "eaglevm-core/virtual_machine/ir/dynamic_encoder/encoder.h"
#include "eaglevm-core/virtual_machine/ir/x86/util.h"
#define HS(x) hash_string::hash(x)

namespace eagle::ir
{
    namespace handler
    {
        jcc::jcc()
        {
            build_options = {
                { { ir_size::bit_32 }, "jo rel32" },
                { { ir_size::bit_32 }, "jno rel32" },

                { { ir_size::bit_32 }, "js rel32" },
                { { ir_size::bit_32 }, "jns rel32" },

                { { ir_size::bit_32 }, "je rel32" },
                { { ir_size::bit_32 }, "jne rel32" },

                { { ir_size::bit_32 }, "jc rel32" },
                { { ir_size::bit_32 }, "jnc rel32" },

                { { ir_size::bit_32 }, "jl rel32" },
                { { ir_size::bit_32 }, "jnl rel32" },

                { { ir_size::bit_32 }, "jle rel32" },
                { { ir_size::bit_32 }, "jnle rel32" },

                { { ir_size::bit_32 }, "jp rel32" },
                { { ir_size::bit_32 }, "jpo rel32" },

                { { ir_size::bit_32 }, "jcxz rel32" },
                { { ir_size::bit_32 }, "jecxz rel32" },
            };
        }

        ir_insts jcc::gen_handler(const uint64_t target_handler_id)
        {
            // method inspired by vmprotect 2
            // https://blog.back.engineering/21/06/2021/#vmemu-virtual-branching

            VM_ASSERT("must by generated by vm implementer");
        }
    }

    namespace lifter
    {
        bool jcc::translate_to_il(const uint64_t original_rva, const x86_cpu_flag flags)
        {
            const auto [condition, inverted] = get_exit_condition(static_cast<codec::mnemonic>(inst.mnemonic));
            auto& [first, second] = codec::calc_relative_rva(inst, operands, original_rva);

            switch (condition)
            {
                case exit_condition::jo:
                case exit_condition::js:
                case exit_condition::je:
                case exit_condition::jb:
                case exit_condition::jp:
                    write_condition_jump(get_flag_for_condition(condition), { });
                    break;
                case exit_condition::jbe:
                    write_bitwise_condition(codec::m_or, ZYDIS_CPUFLAG_CF, ZYDIS_CPUFLAG_ZF, { });
                    break;
                case exit_condition::jl:
                    write_bitwise_condition(codec::m_xor, ZYDIS_CPUFLAG_SF, ZYDIS_CPUFLAG_OF, { });
                    break;
                case exit_condition::jle:
                    write_jle({ });
                    break;
                case exit_condition::jcxz:
                case exit_condition::jecxz:
                case exit_condition::jrcxz:
                    write_check_register(get_register_for_condition(condition), { });
                    break;
                case exit_condition::jmp:
                    block->push_back({
                        std::make_shared<cmd_push>(),
                        std::make_shared<cmd_branch>()
                    });
                    break;
                default:
                    VM_ASSERT("invalid jump condition");
                    break;
            }

            block->push_back(std::make_shared<cmd_branch>({ }, condition, inverted));
            return true;
        }

        void jcc::write_condition_jump(const uint64_t flag_mask, const std::array<il_exit_result, 2>& exits) const
        {
            write_flag_operation(flag_mask, exits, [](uint64_t flag_mask)
            {
                return std::vector<base_command_ptr>{
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 })
                };
            });
        }

        void jcc::write_bitwise_condition(codec::mnemonic mnemonic, uint64_t flag_mask_one, uint64_t flag_mask_two,
            const std::array<il_exit_result, 2>& exits) const
        {
            write_flag_operation(flag_mask_one | flag_mask_two, exits, [mnemonic, flag_mask_one, flag_mask_two](uint64_t)
            {
                return std::vector<base_command_ptr>{
                    std::make_shared<cmd_push>(flag_mask_one, ir_size::bit_64),
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_rflags_load>(),
                    std::make_shared<cmd_push>(flag_mask_two, ir_size::bit_64),
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_handler_call>(mnemonic, handler_sig{ ir_size::bit_64, ir_size::bit_64 })
                };
            });
        }

        void jcc::write_check_register(codec::reg reg, const std::array<il_exit_result, 2>& exits) const
        {
            auto target_size = bits_to_ir_size(get_reg_size(reg));
            write_flag_operation(ZYDIS_CPUFLAG_ZF, exits, [reg, target_size](uint64_t)
            {
                return std::vector<base_command_ptr>{
                    std::make_shared<cmd_context_load>(reg),
                    std::make_shared<cmd_push>(0, target_size),
                    std::make_shared<cmd_handler_call>(codec::m_cmp, handler_sig{ target_size, target_size })
                };
            });
        }

        void jcc::write_jle(const std::array<il_exit_result, 2>& exits) const
        {
            write_flag_operation(ZYDIS_CPUFLAG_SF | ZYDIS_CPUFLAG_OF | ZYDIS_CPUFLAG_ZF, exits, [](uint64_t)
            {
                return std::vector<base_command_ptr>{
                    std::make_shared<cmd_push>(ZYDIS_CPUFLAG_SF, ir_size::bit_64),
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_rflags_load>(),
                    std::make_shared<cmd_push>(ZYDIS_CPUFLAG_OF, ir_size::bit_64),
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_handler_call>(codec::m_xor, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_rflags_load>(),
                    std::make_shared<cmd_push>(ZYDIS_CPUFLAG_ZF, ir_size::bit_64),
                    std::make_shared<cmd_handler_call>(codec::m_and, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                    std::make_shared<cmd_handler_call>(codec::m_or, handler_sig{ ir_size::bit_64, ir_size::bit_64 })
                };
            });
        }

        void jcc::write_flag_operation(uint64_t flag_mask, std::array<il_exit_result, 2> exits,
            const std::function<std::vector<base_command_ptr>(uint64_t)>& operation_generator) const
        {
            long index;
            _BitScanForward(reinterpret_cast<unsigned long*>(&index), flag_mask);

            auto shift_cmd = (index > 3)
                                 ? std::make_shared<cmd_handler_call>(codec::m_shl, handler_sig{ ir_size::bit_64, ir_size::bit_64 })
                                 : std::make_shared<cmd_handler_call>(codec::m_shr, handler_sig{ ir_size::bit_64, ir_size::bit_64 });

            auto get_push_v = [](il_exit_result& exit) -> push_v
            {
                return std::visit([](auto&& arg)
                {
                    return push_v{ std::forward<decltype(arg)>(arg) };
                }, exit);
            };

            std::vector<base_command_ptr> commands = {
                std::make_shared<cmd_push>(get_push_v(exits[0]), ir_size::bit_64),
                std::make_shared<cmd_push>(get_push_v(exits[1]), ir_size::bit_64),
                std::make_shared<cmd_push>(reg_vm::vsp, ir_size::bit_64),
                std::make_shared<cmd_rflags_load>(),
                std::make_shared<cmd_push>(flag_mask, ir_size::bit_64)
            };

            auto operation_commands = operation_generator(flag_mask);
            commands.insert(commands.end(), operation_commands.begin(), operation_commands.end());

            commands.insert(commands.end(), {
                std::make_shared<cmd_push>(std::abs(3 - index), ir_size::bit_64),
                shift_cmd,
                std::make_shared<cmd_handler_call>(codec::m_add, handler_sig{ ir_size::bit_64, ir_size::bit_64 }),
                std::make_shared<cmd_mem_read>(ir_size::bit_64),
                std::make_shared<cmd_branch>()
            });

            block->push_back(commands);
        }

        uint64_t jcc::get_flag_for_condition(const exit_condition condition)
        {
            switch (condition)
            {
                case exit_condition::jo: return ZYDIS_CPUFLAG_OF;
                case exit_condition::js: return ZYDIS_CPUFLAG_SF;
                case exit_condition::je: return ZYDIS_CPUFLAG_ZF;
                case exit_condition::jb: return ZYDIS_CPUFLAG_CF;
                case exit_condition::jp: return ZYDIS_CPUFLAG_PF;
                default: VM_ASSERT("Invalid condition for get_flag_for_condition");
            }
            return 0;
        }

        codec::reg jcc::get_register_for_condition(const exit_condition condition)
        {
            switch (condition)
            {
                case exit_condition::jcxz: return codec::reg::cx;
                case exit_condition::jecxz: return codec::reg::ecx;
                case exit_condition::jrcxz: return codec::reg::rcx;
                default: VM_ASSERT("Invalid condition for get_register_for_condition");
            }
            return codec::reg::none;
        }
    }
}
